{"task_id": "HumanEval/0", "model": "google_gemini", "completion": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n\n# Model: google_gemini\n\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 0.5)\n    False\n    >>> has_close_elements([1.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 1.0, 1.0], 0.1)\n    True\n    \"\"\"\n    # To solve this efficiently, we can first sort the list.\n    # If any two numbers are close, then after sorting, at least one\n    # pair of *adjacent* numbers must be close. This avoids the need for\n    # a nested loop (O(n^2)) and reduces the complexity to sorting (O(n log n))\n    # plus a single pass (O(n)).\n    \n    # Create a sorted copy of the list\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the sorted list and check the difference between\n    # adjacent elements. We only need to go up to the second-to-last element.\n    for i in range(len(sorted_numbers) - 1):\n        # Since the list is sorted, sorted_numbers[i+1] will always be >= sorted_numbers[i],\n        # so the difference is the absolute difference.\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        \n        if diff < threshold:\n            # We found a pair that is closer than the threshold, so we can return True.\n            return True\n            \n    # If the loop completes without finding any close elements, we can return False.\n    return False"}
{"task_id": "HumanEval/10", "model": "google_gemini", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n\n\n# Model: google_gemini\n\n    if not string:\n        return \"\"\n\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            # We found the longest palindromic suffix.\n            # The part of the string that needs to be mirrored is the prefix\n            # that comes before this suffix.\n            prefix = string[:i]\n            # Append the reverse of the prefix to the original string.\n            return string + prefix[::-1]\n    \n    # This part of the code is theoretically unreachable for non-empty strings,\n    # as a single character (the last one) is always a palindrome.\n    # The empty string case is handled at the beginning.\n    return string"}
{"task_id": "HumanEval/20", "model": "google_gemini", "completion": "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\n\n# Model: google_gemini\n\nimport math\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # A brute-force approach would compare every number with every other number,\n    # which is O(n^2). A more efficient approach is to sort the list first.\n    # In a sorted list, the two closest numbers will always be adjacent to each other.\n    # This reduces the problem to a single pass after sorting, making it O(n log n).\n\n    sorted_numbers = sorted(numbers)\n\n    # Initialize the minimum difference and the result pair. Since the list is\n    # guaranteed to have at least two elements, this is a safe starting point.\n    min_difference = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # If the first pair are duplicates, their difference is 0, and no pair can be closer.\n    if min_difference == 0:\n        return closest_pair\n\n    # Iterate through the rest of the adjacent pairs to find if any are closer.\n    # We start from the second element (index 1) since we already processed the first pair.\n    for i in range(1, len(sorted_numbers) - 1):\n        num1 = sorted_numbers[i]\n        num2 = sorted_numbers[i + 1]\n        difference = num2 - num1\n\n        # If we find a new pair with a smaller difference, update our result.\n        if difference < min_difference:\n            min_difference = difference\n            closest_pair = (num1, num2)\n            # Optimization: If we find a difference of 0, we can't do better.\n            if min_difference == 0:\n                break\n\n    return closest_pair"}
{"task_id": "HumanEval/30", "model": "google_gemini", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n\n# Model: google_gemini\n\n    return [num for num in l if num > 0]"}
{"task_id": "HumanEval/5", "model": "google_gemini", "completion": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n\n\n# Model: google_gemini\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    # Iterate through all but the last element\n    for number in numbers[:-1]:\n        result.append(number)\n        result.append(delimeter)\n    \n    # Add the last element without a delimeter after it\n    result.append(numbers[-1])\n    \n    return result"}
